from qdep.internal.common import *
from qdep.internal.prf import *


version = "1.0.0"


def prfgen(arguments, script_path):
	if arguments.dir is not None:
		prf_path = arguments.dir
	else:
		qmake_res = subprocess.run([arguments.qmake, "-query", "QT_HOST_DATA"], check=True, stdout=subprocess.PIPE, encoding="UTF-8")
		prf_path = str(qmake_res.stdout).strip()
	prf_path = path.join(prf_path, "mkspecs", "features", "qdep.prf")
	print("Generating PRF-File as: ", prf_path)
	os.makedirs(path.dirname(prf_path), exist_ok=True)
	with open(prf_path, "w") as prf_file:
		prf_file.write("# Generated by {}\n".format(script_path))
		prf_file.write("qdep_force|!isEmpty(OUT_PWD) {  # Used to detect if qdep was loaded from an indirect evaluation\n\n")
		prf_file.write("isEmpty(QDEP_PATH) {\n")
		prf_file.write("\tQDEP_PATH = {}\n".format(script_path))
		prf_file.write("\twin32: QDEP_PATH = $${QDEP_PATH}.exe\n")
		prf_file.write("}\n")
		prf_file.write("isEmpty(QDEP_VERSION): QDEP_VERSION = {}\n".format(version))
		prf_file.write(qdep_prf)
		prf_file.write("\n}\n")


def init(arguments):
	with open(arguments.profile, "a") as pro_file:
		pro_file.write("\nQDEP_DEPENDS = \n\n")
		pro_file.write("!load(qdep):error(\"Failed to load qdep feature! Run 'qdep.py prfgen --qmake $$QMAKE_QMAKE' to create it.\")\n")


def lupdate(arguments):
	qmake_res = subprocess.run([arguments.qmake, "-query", "QT_HOST_BINS"], check=True, stdout=subprocess.PIPE, encoding="UTF-8")
	lupdate_path = path.join(str(qmake_res.stdout).strip(), "lupdate")
	with tempfile.TemporaryDirectory() as tmp_dir:
		tmp_pro_path = path.join(tmp_dir, "lupdate.pro")
		with open(tmp_pro_path, "w") as tmp_file:
			tmp_file.write("include({})\n".format(arguments.pri_path))
			tmp_file.write("TRANSLATIONS = $$QDEP_TRANSLATIONS\n")
		subprocess.run([lupdate_path] + arguments.largs + [tmp_pro_path], check=True)


def clear(arguments):
	def folder_size(path):
		total = 0
		for entry in os.scandir(path):
			if entry.is_file():
				total += entry.stat().st_size
			elif entry.is_dir():
				total += folder_size(entry.path)
		return total

	if not arguments.yes:
		print("All caches sources will be removed and have to be downloaded again. Make sure no other qdep instance is currently running!")
		ok = input("Do you really want ro remove all cached sources? [y/N]").lower()
		if len(ok) == 0:
			return
		elif ok != "y" and ok != "yes":
			return

	cache_dir = os.getenv("QDEP_CACHE_DIR", get_cache_dir_default())
	cache_dir = path.join(cache_dir, "src")
	if path.exists(cache_dir):
		rm_size = folder_size(cache_dir)
		shutil.rmtree(cache_dir)
	else:
		rm_size = 0
	print("Removed {} bytes".format(rm_size))


def versions(arguments):
	package_url, _v, _p = package_resolve(arguments.package)

	if arguments.tags:
		pkg_tags = get_all_tags(package_url, tags=True, branches=False, allow_empty=True)
		if arguments.limit is not None:
			pkg_tags = pkg_tags[-arguments.limit:]
	else:
		pkg_tags = []

	if arguments.branches:
		pkg_branches = get_all_tags(package_url, tags=False, branches=True, allow_empty=True)
		if arguments.limit is not None:
			pkg_branches = pkg_branches[-arguments.limit:]
	else:
		pkg_branches = []

	if arguments.short:
		print(" ".join(pkg_branches + pkg_tags))
	else:
		if arguments.branches:
			print("Branches:")
			if len(pkg_branches) > 0:
				for branch in pkg_branches:
					print("  " + branch)
			else:
				print(" -- No branches found --")

		if arguments.tags:
			if arguments.branches:
				print("")

			print("Tags:")
			if len(pkg_tags) > 0:
				for tag in pkg_tags:
					print("  " + tag)
			else:
				print(" -- No tags found --")


def query(arguments):
	pkg_url, pkg_version, pkg_path = package_resolve(arguments.package)
	if arguments.check:
		if pkg_version is None:
			pkg_version = get_latest_tag(pkg_url, allow_empty=True, allow_error=True)
			pkg_exists = pkg_version is not None
		else:
			pkg_exists = pkg_version in get_all_tags(pkg_url, branches=True, tags=True, allow_empty=True, allow_error=True)
	else:
		pkg_exists = False  # not knowing means false

	if arguments.expand:
		if pkg_version is None:
			raise Exception("Unable to determine package version")
		else:
			print("{}@{}{}".format(pkg_url, pkg_version, pkg_path))
	else:
		print("Input:", arguments.package)
		if pkg_version is not None:
			print("Expanded Name: {}@{}{}".format(pkg_url, pkg_version, pkg_path))
		else:
			print("Expanded Name:", None)
		print("URL:", pkg_url)
		print("Version:", pkg_version)
		print("Path:", pkg_path)
		if arguments.check:
			print("Exists:", pkg_exists)

		if arguments.versions:
			print("")
			t_args = type("QueryVersionArgs", (), {
				"branches": True,
				"tags": True,
				"short": False,
				"limit": None,
				"package": arguments.package
			})
			versions(t_args)


def get(arguments):
	print(arguments)

	if arguments.dir is not None:
		os.environ["QDEP_CACHE_DIR"] = arguments.dir

	# eval the pro files if needed
	if arguments.eval:
		# special case: since we only download sources, a simple qmake run is enough, no actual "evaluation" needed
		for pro_file in arguments.args:
			with tempfile.TemporaryDirectory() as tmp_dir:
				print("Running {} on {}...".format(arguments.qmake, pro_file))
				subprocess.run([arguments.qmake, pro_file], cwd=tmp_dir, check=True, stdout=subprocess.DEVNULL)
				print("Running {} qmake_all...".format(arguments.make))
				subprocess.run([arguments.make, "qmake_all"], cwd=tmp_dir, check=True, stdout=subprocess.DEVNULL)
				print("Done! qmake finished successfully, all qdep sources for the project tree have been downloaded.")
		return
	elif arguments.extract:
		packages = []
		for pro_file in arguments.args:
			packages = packages + eval_pro_file(pro_file, arguments.qmake, arguments.make, full_eval=False)
	else:
		packages = arguments.args

	# download the actual sources
	print("Downloading {} packages total".format(len(packages)))
	for package in packages:
		print("Downloading sources for {}...".format(package))
		pkg_url, pkg_version, _p = package_resolve(package)
		get_sources(pkg_url, pkg_version)
		print("Done!")
